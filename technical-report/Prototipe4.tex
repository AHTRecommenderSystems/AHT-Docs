\chapter{Prototipo 4: Desarrollo de un sistema híbrido de recomendación de platillos}
  \section{Análisis}
    \subsection{Objetivo}
      Desarrollar un sistema híbrido para la recomendación de platillos que conlleve la demostración de la funcionalidad proporcionada por el API en un caso de estudio particular.

    \subsection{Características}
    \begin{itemize}
      \item El sistema permitirá realizar recomendaciones de platillos de acuerdo a sus características de los mismos (basadas en contenido).
      \item El sistema permitirá realizar recomendaciones de platillos con base en la interacción de los usuarios finales a través de ratings o evaluaciones cuantitativas (por filtrado colaborativo).
      \item El sistema permitirá el registro de usuarios finales, así como su autenticación para el uso de las funcionalidades del sistema.
      \item El sistema permitirá la visualización de los platillos a los usuarios no registrados.
      \item El sistema permitirá la recomendación para los usuarios no registrados a través del manejo de cookies en el navegdor y su interacción con los platillos.
    \end{itemize}

    \subsection{Restricciones}
    \begin{itemize}
      \item El sistema se verá limitado a las características y cantidad de platillos registrados para realizar las recomendaciones.
      \item El sistema no permitirá el registro de platillos a usuarios no registrados.
    \end{itemize}

    % Insertar historias de usuario aqui

  \section{Diseño}

    Para desarrollar las características mencionadas previamente, se debe tomar en cuenta el modelo de datos propio del caso de estudio que podemos observar en la figura ~\ref{fig:model_cs}

    \begin{landscape}
      \begin{figure}[h!]
        \centering
        \includegraphics[width=25cm]{./images/sc_data_model}
        \caption{Modelo de datos del caso de estudio}
        \label{fig:model_cs}
      \end{figure}
    \end{landscape}

    El diseño de las clases acordes a este modelo de datos: User, Dish, Characteristic y Restaurant, así como sus relaciones producto de la interacción entre ellos: Affinity, Neighbor, Upload, Click y Rate, permiten aunado a la funcionalidad propia del API realizar el conjunto de recomendaciones de acuerdo a las necesidades del sistema. Para esto, se desarrollaron un conjunto de clases para exponer, a través de servicios web, las operaciones básicas de un CRUD de las clases de dominio User, Dish, Category y Restaurant así como para la creación de las relaciones entre estas entidades y las recomendaciónes obtenidas.

  Para el desarrollo de los servicios web se considera lo siguiente: un recurso que identificará a cada una de estas clases, en este caso, la entidad a la que hacen referencia concatenando la palabra "ws" para mayor referencia; así como nombre del recurso que identificará a cada uno de los métodos de esta clase indicado por los métodos que manipulan las cinco operaciones del CRUD (Create, Retrieve, Update, Delete y RetrieveAll). Igualmente para exponer los web services de las recomendaciones, se utliza el nombre de los métodos propios del recomendador. Por último, se debe declarar el tipo de respuesta que tienen estos métodos. Para cada uno de ellos se regresa una respuesta que contiene un JSON; cada uno de los JSON posee un campo llamado success, el cual actua como un indicador de si la operacion fue éxitosa o no.

  \section{Resultados}
    Utilizando el comportamiento de la API como parte de la funcionalidad del sistema, integrado con las clases de dominio y los servicios diseñados previamente obtenemos la estructura mostrada en el diagrama de clases de la figura~\ref{fig:monster_classes}. 

    \begin{landscape}
      \begin{figure}[h!]
        \centering
        \includegraphics[width=25cm]{./images/monster_class}
        \caption{Diagrama de clases del prototipo 4}
        \label{fig:monster_classes}
      \end{figure}
    \end{landscape}

    Así finalmente se desarrolla el sistema web del caso de estudio, consumiendo los servicios web proporcionados por el back-end del sistema en una aplicación desarrollada con Angular.js, que a través de servicios y controladores que siguen el patrón MVC, permiten mostrar los datos en una interfaz gráfica al usuario final acorde a las características necesarias, como la mostrada en la figura~\ref{fig:final_bonappettit}


      \begin{figure}[h!]
        \centering
        \includegraphics[width=16cm]{./images/p4_bonappettit}
        \caption{Interfaz gráfica del sistema}
        \label{fig:final_bonappettit}
      \end{figure}

